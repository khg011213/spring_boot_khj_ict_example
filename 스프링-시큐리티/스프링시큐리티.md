===================================================================================================
스텝 1

dependency만 추가해도 Spring Security에서 제공하는 가장 기본적인 인증이 바로 적용됨

기본 로그인 화면이 가장 먼저 나올 것이다.
Username : user (기본 계정)
Password : 비밀번호는 어플리케이션 기동할때 로그로 나오는 Using generated security password 정보
Using generated security password: 0d07e7fd-0fba-403d-9eff-149ac84f4d56

This generated password is for development use only. Your security configuration must be updated before running your application in production.


###스프링 스큐리티(알렉스 아저씨) 인증 방식은 세션 쿠키 방식 임

==================================================================================
스텝 2
   이미지(가영이)가 보이지 않는다.
   우선 정적파일들은 시큐리티에 적용되지 않도록 아래와 같이 설정을 한다.
   이제 더이상 리소스파일들은 스프링 시큐리티에서 관리를 하지 않는다.   

   @Override
   public void configure(WebSecurity web) throws Exception {
      // web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
      web.ignoring().antMatchers("/css/**", "/js/**", "/img/**", "/lib/**");
   }
   
   
=====================================================================================================
스텝 3

이제 설정에서 유저를 생성한후 , 다시 한번 접속해 보자 , 로그인 창에서 아래의 이름과 비밀번호로 접속해 보자. 그럼 헬로우 월드가 보인다.
   
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception {
       auth.inMemoryAuthentication()
               .withUser("member").password("{noop}member").roles("USER").and()
               .withUser("admin").password("{noop}admin").roles("ADMIN");
   }
=====================================================================================================

스텝 4.

##권한 설정

home.jsp를 제대로 만들고, 아래와 같이 설정하여 / 로 접속후 home.jsp 가 나오는것을 확인한다.

인증 = 로그인 (문열고 들어감) 
권한  = 리소스 접근 (들어갈수있는 방에 있는 리소스)

   @Override
   protected void configure(HttpSecurity http) throws Exception {
      //우선 CSRF설정을 해제한다.
      //초기 개발시만 해주는게 좋다.
      http.csrf().disable();
      
      http.authorizeRequests()
      .antMatchers("/member/**").hasAnyRole("ROLE_MEMBER") 
      .antMatchers("/admin/**").hasAnyRole("ROLE_ADMIN")
      .antMatchers("/**").permitAll();      
   }

========================================================================================
스텝 5.

## 기본 로그인 폼을 사용 하기 위한 설정
   protected void configure(HttpSecurity http) throws Exception {
      //우선 CSRF설정을 해제한다.
      //초기 개발시만 해주는게 좋다.
      http.csrf().disable();
      
      http.authorizeRequests()
      .antMatchers("/user/**").hasAnyRole("USER") 
      .antMatchers("/admin/**").hasAnyRole("ADMIN")
      .antMatchers("/**").permitAll();
      
      http.formLogin(); //스프링 시큐리티에 있는 기본 로그인 폼을 사용하겠다.

=================================================================================================================================
스텝 6.

##DB 작업 및 UserMapper 생성



=======================================================================================================================================

스텝 7

## 로그인 페이지 커스터 마이징

기본 로그인 폼 : 스프링 시큐리티가 가진 디폴트 로그인 페이지를 보내줌


//로그인폼 커스터마이징
		//http.formLogin(); // 스프링 시큐리티에 있는 기본 로그인 폼을 사용하겠다.
		http.formLogin()
		.loginPage("/login")
		.usernameParameter("id")
		.passwordParameter("pw")
		.defaultSuccessUrl("/");
		
		
===============================================================================================================================
스텝 8.

###패스워드 암호화 저장

암호화 모듈 종류 참고사이트
https://velog.io/@hyeinisfree/SpringSecurity-PasswordEncoder

PasswordEncoders
Spring Security는 PasswordEncoder라는 인터페이스를 이용해 암호가 안전하게 저장될 수 있도록 암호의 단방향 변환을 지원합니다. 
PasswordEncoder라는 인터페이스의 구현체로 BCryptPasswordEncoder, Argon2PasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder 등 많은 PasswordEncoder가 있습니다. 


  @Test
	   void testInsertUser() {
	      
	      UserVO user = new UserVO();
	      user.setUsername("admin2");
	      user.setPassword(passwordEncoder.encode("admin2"));
	      user.setEnabled("1");
	      
	      userMapper.insertUser(user);
	      userMapper.insertAuthorities(user);      
	         
	      assertNotNull(user);
	      
	      System.out.println(user);
			
			admin admin 계정 생성 후 밑 테스트에서  pw 암호화 결과 확인 하는 test 코드
	}
	   
	   
	   @Test
	   void testMatcher() {
	      
	      UserVO user = userMapper.getUser("admin2");
	      boolean isMatch = passwordEncoder.matches("admin2", user.getPassword());
	      
	      System.out.println(user.getPassword());
	      assertEquals(isMatch, true);
	     

	}


==================================================================================================================================
스텝9 

### 이제 DB와 연결하여 시큐리티를 커스터 마이징 하여보자


UserDetails 와 UserDetailsService 를 구현하여 완성


public class CustomUserDetailsService implements UserDetailsService{

	@Autowired
	private UserMapper userMapper;
	
	
	
	//user의 정보를 주고받기 위한 Fax = UserDetailsService
	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		log.warn("Load User By UserVO user : " + username);
		
		
		//로그인 화면에서 값을 받아서 내 db의 username과 비교한다 그후 존재하는 username이면 UserDetailsVO에 들어가서 로그인 로직 구현
		UserVO user = userMapper.getUser(username);
		
		log.warn("queried by UserVO mapper : " + user);
		
		
		return user == null ? null : new UserDetailsVO(user);
	}
	
	
}


==================================================================================================================================
스텝10 

#시큐리티 태그 활용 및 세션

태그라이브러리 사용하기 위해서 아래의 추가
<%@ taglib uri="http://www.springframework.org/security/tags" prefix="s" %>

표현식                              설명
hasRole('role')   해당 권한이 있을 경우
hasAnyRole('role1,'role2')   포함된 권한 중 하나라도 있을 경우
isAuthenticated()   권한에 관계없이 로그인 인증을 받은 경우
isFullyAuthenticated()   권한에 관계없이 인증에 성공했고, 자동 로그인이 비활성인 경우
isAnonymous()   권한이 없는 익명의 사용자일 경우
isRememberMe()   자동 로그인을 사용하는 경우
permitAll   모든 경우 출력함
denyAll   모든 경우 출력하지 않음

권한에 따른 조건문

<!-- 표현식이 지정한 권한에 맞을 때만 출력 -->
<sec:authorize access="isAnonymous()">
   로그인
   회원가입
</sec:authorize>

<sec:authorize access="isAuthenticated()">
   로그아웃
   회원정보보기
</sec:authorize>

<sec:authorize access="hasRole('admin')">
  관리자 페이지
</sec:authorize>



[ 사용자 정보 확인 ]

<s:authentication property="principal" var="user"/> 
타입 : ${user} <br>
ID : ${user.username} <br>
PW : ${user.password}
</s:authorize>


========================================================================================

스텝 11

### CSRF 란?

Cross Site Request Forgery

사이트간 요청 위조를 하여 src안에 있는 getmapping 을 이용해 아이디 비번을 탈취
방지 방법 : 랜덤이미지를 이용해 인증하는법
토큰 사용방법 : 토큰을 생성하여 그값을 비교하여 대조하는 방식 매번 value  값이 바뀌기 때문에 해킹이 사실상 불가능

http.csrf(csrf -> csrf.disable()); securityConfig에서 CSRF를 컨트롤 하는 코드

 <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" /> 랜덤토큰을 생성하는 코드
















